# Docker Volumes: Storage and Data Persistence

This guide explains Docker volumes, their types, and practical examples including TLS certificate management in containerized environments.

## 1. What is Docker Volume?

### Definition
A Docker volume is a **persistent storage mechanism** that allows data to survive **container** restarts, deletions, and recreation. Unlike container filesystems (which are ephemeral), volumes provide **durable data storage** for containers.

### Why We Need Volumes

**Problems Volumes Solve:**
- **Data Persistence**: Container data disappears when container is removed
- **Data Sharing**: Multiple containers accessing same data
- **Performance**: Avoid copying data into container layers
- **Backup/Restore**: Easy data management outside containers
- **Security**: Isolate sensitive data from container images

**Key Characteristics:**
- **Independent Lifespan**: Volumes exist beyond container lifecycle
- **Host Integration**: Can be managed by Docker or mapped to host filesystem
- **Performance**: Optimized for Docker's storage drivers
- **Portability**: Can be backed up, restored, and migrated

## 2. Docker Volume Types

### Named Volumes (Recommended)
- **Syntax**: `volume_name:container_path[:options]`
- **Management**: Docker-managed storage
- **Declaration**: Required in `volumes:` section
- **Persistence**: Survives container deletion
- **Sharing**: Can be mounted by multiple containers
- **Portability**: High (no host dependencies)

**Example:**
```yaml
services:
  app:
    volumes:
      - mydata:/app/data

volumes:
  mydata:
    driver: local
```

### Host Path Mounts (Bind Mounts)
- **Syntax**: `/host/path:container_path[:options]`
- **Management**: Direct host filesystem access
- **Declaration**: Not required
- **Persistence**: Tied to host filesystem
- **Sharing**: Host-dependent
- **Portability**: Low (host-specific paths)

**Example:**
```yaml
services:
  app:
    volumes:
      - /tmp/host-data:/app/data
```

### Anonymous Volumes
- **Syntax**: Just `:container_path`
- **Management**: Docker assigns random name
- **Declaration**: Not required
- **Persistence**: Survives container deletion (until explicitly removed)
- **Sharing**: Limited to single container
- **Portability**: Low (random names)

**Example:**
```yaml
services:
  app:
    volumes:
      - /app/cache  # Anonymous volume
```

## 3. Volume Options and Flags

### Read-Only Mounts
```yaml
volumes:
  - myvolume:/app/config:ro  # Read-only
```

**Purpose**: Security, prevent accidental data modification

### Read-Write Mounts (Default)
```yaml
volumes:
  - myvolume:/app/data:rw  # Read-write (explicit)
  - myvolume:/app/data     # Read-write (default)
```

### SELinux Labels (Linux)
```yaml
volumes:
  - myvolume:/app/data:Z    # Private unshared label
  - myvolume:/app/data:z    # Shared label
```

## 4. Practical Example: Jenkins + Docker-in-Docker with TLS Certificates
Jenkins uses Docker Daemon to run ephemeral containers. For Jenkins to connect to the daemon it needs the certificates generated by the Daemon. 
This is acheived through *shared volumes* 

### Volume Setup in Docker Compose

```yaml
version: '3.8'

services:
  jenkins:
    build: .
    volumes:
      - jenkins_home:/var/jenkins_home          # Named volume for Jenkins data
      - jenkins_certs:/certs/client:ro          # Named volume for TLS certs (read-only)
    environment:
      DOCKER_CERT_PATH: /certs/client
      DOCKER_TLS_VERIFY: 1

  docker_daemon:
    image: docker:dind
    privileged: true
    volumes:
      - jenkins_certs:/certs/client              # Named volume for TLS certs (read-write)
    environment:
      DOCKER_TLS_CERTDIR: /certs

volumes:
  jenkins_home:                                  # Jenkins configuration and jobs
    driver: local
  jenkins_certs:                                 # TLS certificates
    driver: local
```
#### Whats happening here ? 
- Docker Daemon looks at `DOCKER_CERT_PATH` and generates the certificates on the path `/certs/client` on the Daemon container location. 
- The path `/certs/client` is mounted with a named volume `jenkins_certs`
- These volumes are located on the host probably in `/var/lib/docker/volumes/<all volumes>` 
- Jenkins will look at `DOCKER_CERT_PATH` `/certs/client`, this specific path is mounted to volume `jenkins_certs` in this line `jenkins_certs:/certs/client:ro` with read only option
- So volume acts a linker between container  which can write/read based on the permissions given


#### Volume Storage
```
┌─────────────────────────────────┐     ┌─────────────────────────────────┐
│      docker_daemon container    │     │       jenkins container         │
│                                 │     │                                 │
│  /                              │     │  /                              │
│  ├── bin/                       │     │  ├── bin/                       │
│  ├── etc/                       │     │  ├── var/jenkins_home/          │
│  ├── certs/                     │     │  ├── certs/                     │
│  │   └── client/ ◄──────────────┼─────┼──────► client/                  │
│  │       ├── ca.pem             │     │       ├── ca.pem                │
│  │       ├── cert.pem           │     │       ├── cert.pem              │
│  │       └── key.pem            │     │       └── key.pem               │
│  └── ...                        │     │  └── ...                        │
└─────────────────────────────────┘     └─────────────────────────────────┘
         │                                        │
         │  WRITES to volume                      │  READS from volume
         │                                        │
         └────────────┬───────────────────────────┘
                      │
              ┌───────▼───────┐
              │ Named Volume  │
              │ jenkins_certs │
              │ (on host)     │
              └───────────────┘
```

### Why Named Volumes for Certificates

**Advantages Over Host Paths:**
- **Portability**: Same setup works across different hosts
- **Isolation**: Certificates not visible on host filesystem
- **Security**: No host path exposure of sensitive TLS keys
- **Management**: Docker handles volume lifecycle

**Comparison:**

| Approach | Host Path | Named Volume |
|----------|-----------|--------------|
| **Storage** | `/host/jenkins/certs` | Docker-managed |
| **Visibility** | Host can access | Host cannot access |
| **Portability** | Host-dependent | Environment-agnostic |
| **Security** | Potentially exposed | Isolated in Docker |

## 5. Volume Management Commands

### Create Volume
```bash
docker volume create myvolume
```

### List Volumes
```bash
docker volume ls
```

### Inspect Volume
```bash
# Shows mount point on host, driver, and metadata
docker volume inspect myvolume
```

### View Volume Contents
```bash
# From host (Linux only)
sudo ls -la /var/lib/docker/volumes/jenkins_certs/_data

# From inside a running container
docker exec -it <container_name> ls -la /certs/client

# On macOS/Windows (Docker runs in VM, so use a temp container)
docker run --rm -it -v jenkins_certs:/data alpine ls -la /data
```

### Remove Volume
```bash
docker volume rm myvolume
```

### Prune Unused Volumes
```bash
docker volume prune
```

## 6. Best Practices for Volumes

### Data Classification
- **Application Data**: Use named volumes
- **Configuration**: Use named volumes with `:ro`
- **Logs**: Consider host paths for monitoring
- **Secrets**: Use named volumes with strict permissions

### Security Considerations
- Apply `:ro` flag where possible
- Use named volumes for sensitive data (not host paths)
- Regularly backup important volumes
- Clean up unused volumes

### Performance Tips
- Use named volumes for I/O intensive workloads
- Avoid host paths for database data (use named volumes)
- Monitor volume usage with `docker system df -v`

### Backup and Recovery
```bash
# Backup named volume
docker run --rm -v myvolume:/data -v $(pwd):/backup alpine tar czf /backup/volume-backup.tar.gz -C /data .

# Restore named volume
docker run --rm -v myvolume:/data -v $(pwd):/backup alpine tar xzf /backup/volume-backup.tar.gz -C /data
```

## 7. Common Volume Patterns

### Database Persistence
```yaml
services:
  db:
    image: postgres
    volumes:
      - db_data:/var/lib/postgresql/data

volumes:
  db_data:
```

### Shared Configuration
```yaml
services:
  app1:
    volumes:
      - shared_config:/app/config:ro
  app2:
    volumes:
      - shared_config:/app/config:ro

volumes:
  shared_config:
```

### Development Overrides
```yaml
services:
  app:
    volumes:
      - .:/app/src  # Host path for live code changes
      - node_modules:/app/node_modules  # Named volume for dependencies
```

## Summary

Docker volumes provide essential data persistence and sharing capabilities:

- **Named Volumes**: Docker-managed, portable, secure storage
- **Host Paths**: Direct filesystem access, host-dependent
- **Anonymous Volumes**: Temporary, Docker-assigned storage

For the Jenkins + Docker setup, named volumes ensure secure, portable TLS certificate management while maintaining data persistence across container lifecycles. This pattern is widely used in production containerized applications for reliable data handling.
